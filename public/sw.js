// Service Worker for Naraflow PWA
// This file will be generated by vite-plugin-pwa, but we provide a base configuration

const CACHE_NAME = 'naraflow-v1';
const STATIC_CACHE_NAME = 'naraflow-static-v1';
const DYNAMIC_CACHE_NAME = 'naraflow-dynamic-v1';

// Assets to cache immediately
const STATIC_ASSETS = [
  '/',
  '/workflow-studio',
  '/about',
  '/how-it-works',
  '/pricing',
  '/solutions',
  '/faq',
  '/contact',
  '/manifest.json',
  '/favicon.ico',
  '/placeholder.svg',
  '/robots.txt'
];

// API endpoints that should be cached
const API_CACHE_PATTERNS = [
  /^https:\/\/api\./,
  /^https:\/\/localhost:11434/,
  /^https:\/\/.*\.llama/
];

// File extensions to cache
const CACHEABLE_EXTENSIONS = [
  '.js',
  '.css',
  '.json',
  '.svg',
  '.png',
  '.jpg',
  '.jpeg',
  '.gif',
  '.webp',
  '.woff',
  '.woff2',
  '.ttf',
  '.eot'
];

// Install event - cache static assets
self.addEventListener('install', (event) => {
  console.log('Service Worker: Installing...');
  
  event.waitUntil(
    caches.open(STATIC_CACHE_NAME)
      .then((cache) => {
        console.log('Service Worker: Caching static assets');
        return cache.addAll(STATIC_ASSETS);
      })
      .then(() => {
        console.log('Service Worker: Installation complete');
        return self.skipWaiting();
      })
      .catch((error) => {
        console.error('Service Worker: Installation failed', error);
      })
  );
});

// Activate event - clean up old caches
self.addEventListener('activate', (event) => {
  console.log('Service Worker: Activating...');
  
  event.waitUntil(
    caches.keys()
      .then((cacheNames) => {
        return Promise.all(
          cacheNames.map((cacheName) => {
            if (cacheName !== STATIC_CACHE_NAME && 
                cacheName !== DYNAMIC_CACHE_NAME) {
              console.log('Service Worker: Deleting old cache', cacheName);
              return caches.delete(cacheName);
            }
          })
        );
      })
      .then(() => {
        console.log('Service Worker: Activation complete');
        return self.clients.claim();
      })
      .catch((error) => {
        console.error('Service Worker: Activation failed', error);
      })
  );
});

// Fetch event - implement caching strategies
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);

  // Skip non-GET requests
  if (request.method !== 'GET') {
    return;
  }

  // Skip chrome-extension and other non-http requests
  if (!url.protocol.startsWith('http')) {
    return;
  }

  // Handle different types of requests
  if (isStaticAsset(request)) {
    event.respondWith(handleStaticAsset(request));
  } else if (isAPIRequest(request)) {
    event.respondWith(handleAPIRequest(request));
  } else if (isPageRequest(request)) {
    event.respondWith(handlePageRequest(request));
  } else {
    event.respondWith(handleOtherRequest(request));
  }
});

// Check if request is for static assets
function isStaticAsset(request) {
  const url = new URL(request.url);
  return CACHEABLE_EXTENSIONS.some(ext => url.pathname.endsWith(ext)) ||
         url.pathname.includes('/assets/') ||
         url.pathname.includes('/node_modules/');
}

// Check if request is for API
function isAPIRequest(request) {
  const url = new URL(request.url);
  return API_CACHE_PATTERNS.some(pattern => pattern.test(url.href)) ||
         url.pathname.startsWith('/api/');
}

// Check if request is for a page
function isPageRequest(request) {
  const url = new URL(request.url);
  return url.origin === location.origin && 
         !url.pathname.includes('.') &&
         request.headers.get('accept')?.includes('text/html');
}

// Handle static assets with cache-first strategy
async function handleStaticAsset(request) {
  try {
    const cache = await caches.open(STATIC_CACHE_NAME);
    const cachedResponse = await cache.match(request);
    
    if (cachedResponse) {
      return cachedResponse;
    }

    const networkResponse = await fetch(request);
    
    if (networkResponse.ok) {
      cache.put(request, networkResponse.clone());
    }
    
    return networkResponse;
  } catch (error) {
    console.error('Service Worker: Static asset fetch failed', error);
    return new Response('Asset not available offline', { status: 404 });
  }
}

// Handle API requests with network-first strategy
async function handleAPIRequest(request) {
  try {
    const networkResponse = await fetch(request);
    
    if (networkResponse.ok) {
      const cache = await caches.open(DYNAMIC_CACHE_NAME);
      cache.put(request, networkResponse.clone());
    }
    
    return networkResponse;
  } catch (error) {
    console.log('Service Worker: API request failed, trying cache', error);
    
    const cache = await caches.open(DYNAMIC_CACHE_NAME);
    const cachedResponse = await cache.match(request);
    
    if (cachedResponse) {
      return cachedResponse;
    }
    
    return new Response('API not available offline', { 
      status: 503,
      statusText: 'Service Unavailable'
    });
  }
}

// Handle page requests with network-first strategy
async function handlePageRequest(request) {
  try {
    const networkResponse = await fetch(request);
    
    if (networkResponse.ok) {
      const cache = await caches.open(DYNAMIC_CACHE_NAME);
      cache.put(request, networkResponse.clone());
    }
    
    return networkResponse;
  } catch (error) {
    console.log('Service Worker: Page request failed, trying cache', error);
    
    const cache = await caches.open(DYNAMIC_CACHE_NAME);
    const cachedResponse = await cache.match(request);
    
    if (cachedResponse) {
      return cachedResponse;
    }
    
    // Fallback to offline page
    const offlineResponse = await cache.match('/');
    return offlineResponse || new Response('Page not available offline', { 
      status: 404,
      statusText: 'Not Found'
    });
  }
}

// Handle other requests with cache-first strategy
async function handleOtherRequest(request) {
  try {
    const cache = await caches.open(DYNAMIC_CACHE_NAME);
    const cachedResponse = await cache.match(request);
    
    if (cachedResponse) {
      return cachedResponse;
    }

    const networkResponse = await fetch(request);
    
    if (networkResponse.ok) {
      cache.put(request, networkResponse.clone());
    }
    
    return networkResponse;
  } catch (error) {
    console.error('Service Worker: Other request failed', error);
    return new Response('Resource not available offline', { status: 404 });
  }
}

// Background sync for offline actions
self.addEventListener('sync', (event) => {
  console.log('Service Worker: Background sync triggered', event.tag);
  
  if (event.tag === 'workflow-execution') {
    event.waitUntil(syncWorkflowExecutions());
  } else if (event.tag === 'template-sync') {
    event.waitUntil(syncTemplates());
  }
});

// Sync workflow executions when back online
async function syncWorkflowExecutions() {
  try {
    // Get pending executions from IndexedDB
    const pendingExecutions = await getPendingExecutions();
    
    for (const execution of pendingExecutions) {
      try {
        await executeWorkflow(execution);
        await removePendingExecution(execution.id);
        console.log('Service Worker: Synced execution', execution.id);
      } catch (error) {
        console.error('Service Worker: Failed to sync execution', execution.id, error);
      }
    }
  } catch (error) {
    console.error('Service Worker: Background sync failed', error);
  }
}

// Sync templates when back online
async function syncTemplates() {
  try {
    // Get pending template operations from IndexedDB
    const pendingOperations = await getPendingTemplateOperations();
    
    for (const operation of pendingOperations) {
      try {
        await processTemplateOperation(operation);
        await removePendingTemplateOperation(operation.id);
        console.log('Service Worker: Synced template operation', operation.id);
      } catch (error) {
        console.error('Service Worker: Failed to sync template operation', operation.id, error);
      }
    }
  } catch (error) {
    console.error('Service Worker: Template sync failed', error);
  }
}

// Message handling for communication with main thread
self.addEventListener('message', (event) => {
  const { type, data } = event.data;
  
  switch (type) {
    case 'SKIP_WAITING':
      self.skipWaiting();
      break;
      
    case 'CACHE_URLS':
      event.waitUntil(cacheUrls(data.urls));
      break;
      
    case 'CLEAR_CACHE':
      event.waitUntil(clearCache(data.cacheName));
      break;
      
    case 'GET_CACHE_SIZE':
      event.waitUntil(getCacheSize().then(size => {
        event.ports[0].postMessage({ size });
      }));
      break;
      
    default:
      console.log('Service Worker: Unknown message type', type);
  }
});

// Cache specific URLs
async function cacheUrls(urls) {
  const cache = await caches.open(DYNAMIC_CACHE_NAME);
  
  for (const url of urls) {
    try {
      const response = await fetch(url);
      if (response.ok) {
        await cache.put(url, response);
      }
    } catch (error) {
      console.error('Service Worker: Failed to cache URL', url, error);
    }
  }
}

// Clear specific cache
async function clearCache(cacheName) {
  const cache = await caches.open(cacheName);
  const keys = await cache.keys();
  
  for (const key of keys) {
    await cache.delete(key);
  }
}

// Get cache size
async function getCacheSize() {
  const cacheNames = await caches.keys();
  let totalSize = 0;
  
  for (const cacheName of cacheNames) {
    const cache = await caches.open(cacheName);
    const keys = await cache.keys();
    
    for (const key of keys) {
      const response = await cache.match(key);
      if (response) {
        const blob = await response.blob();
        totalSize += blob.size;
      }
    }
  }
  
  return totalSize;
}

// Helper functions for IndexedDB operations (simplified)
async function getPendingExecutions() {
  // This would interact with IndexedDB to get pending executions
  // For now, return empty array
  return [];
}

async function removePendingExecution(id) {
  // This would remove the execution from IndexedDB
  console.log('Service Worker: Removed pending execution', id);
}

async function executeWorkflow(execution) {
  // This would execute the workflow
  console.log('Service Worker: Executing workflow', execution);
}

async function getPendingTemplateOperations() {
  // This would interact with IndexedDB to get pending template operations
  return [];
}

async function removePendingTemplateOperation(id) {
  // This would remove the operation from IndexedDB
  console.log('Service Worker: Removed pending template operation', id);
}

async function processTemplateOperation(operation) {
  // This would process the template operation
  console.log('Service Worker: Processing template operation', operation);
}

console.log('Service Worker: Script loaded');
